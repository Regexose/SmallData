from collections import Counter
import copy


class Tonality:
    '''
    idea of tonality counter combined with rules for FX chains and Sample Triggering in
    Ableton Live
    '''

    tonality_counter = Counter()

    chain_duration = 5  # specifies how many utterances are needed to change the tonality
    tonality_lock = False
    min_utts = 5

    category_to_chain = {
        # every category points to a FX Chain and a ctrl value
        'praise': ['Delay', 5],
        'lecture': ['Vocoder', 8],
        'insinuation': ['FreqShift', -7],
        'dissence': ['Distortion', -5],
        'concession': ['Delay', 2]
    }
    chain_controls = {
        # every chain refers to a LIVE FX Bus  with a Audio Effekt Rack
        # the Rack has a value for the Chain Selector, a ccnr (for Osculator) and a standard ctrl_value
        'FreqShift': [15, 10, 65],
        'Vocoder': [32, 15, 95],
        'Distortion': [60, 20, 25],
        'Delay': [90, 25, 65],
        'Clean': [115, 0, 0]
    }

    def __init__(self, categories, synth):
        self.tonality_counter = Counter(categories)
        self.synth = synth
        self.FX_KEY = 'Clean'
        self.chain = self.chain_controls[self.FX_KEY]
        self.ctrl_val = 0 # the value being sent with SongServer.send_fx is calculated with calculate_rack_values
        self.last_cats = []
        self.last_value = 0
        self.most_common = ''

    def update_tonality(self, cat):
        self.tonality_counter[cat] += 1
        self.calculate_rack_values(cat)
        # print("tonality counter: ", self.tonality_counter)

    def calculate_rack_values(self, cat):
        '''
        1. after 10 utterances, the most_common category defines the FX chain
        2. only if all other categories have had at least had 5 updates (self.last_cats), a new FX_kEY is
        generated by the most_common category at that moment
        3. the self.ctrl_value is calculated as a deviation from a standard value defined in self.chain_controls
        '''
        self.most_common = self.tonality_counter.most_common(1)[0][0]

        #  an FX chain is selected, if more than 10 entries have occured
        if sum(self.tonality_counter.values()) > self.min_utts:
            # print("cat {}   locked?: {} most common: {}".format(cat, self.tonality_lock, self.most_common))
            if not self.tonality_lock:
                self.FX_KEY = self.category_to_chain[self.most_common][0]
                self.tonality_lock = True
            if cat not in self.last_cats and self.tonality_counter[cat] % self.chain_duration == 0:
                self.last_cats.append(cat)
            elif len(self.last_cats) == len(self.tonality_counter):
                print("\t RESET FX")
                self.synth.reset_synth()
                self.tonality_lock = False
                self.last_cats = []

        self.chain = self.chain_controls[self.FX_KEY]
        self.last_value = self.chain[2]
        self.ctrl_val = self.last_value + self.category_to_chain[cat][1]
        self.synth.calculate_synth_message(cat, self.most_common, self.category_to_chain[cat][1])


class SynthFeedback:
    '''
    this calculates controller values for LIVE MIDI Slots with Synthesizers
    an incoming category defines the slot for the synth to be manipulated
    every synth has 5 ccnr with standard values
    the values for each controller deviate from the last value according to the Tonality.ctrl_val
    '''
    tonality_counter = Counter()
    synth_controls = {
        # every control refers to a LIVE MIDI Track with a loaded Synth
        # the Synth has a value for the ccnr (for Osculator) and a standard ctrl_value
        # most synth makro controllers have values from 0-100, some -100-100 or 0.1 - 1.0
        # ideally the values can be transformed by Osculators value mapping
        # default values start at 0
        'c0': [5, 20],
        'c1': [10, 20],
        'c2': [15, 20],
        'c3': [20, 20],
        'c4': [25, 20]
    }
    cat2synth = {
        # 1st value points to the controller that is altered according to a incoming cat
        # important to store the values of the different synths
        'praise': ['c0', synth_controls],
        'lecture': ['c1', synth_controls],
        'insinuation': ['c2', synth_controls],
        'dissence': ['c3', synth_controls],
        'concession': ['c4', synth_controls]
    }

    def __init__(self):
        self.ctrl_message = [v[1] for v in self.synth_controls.values()]

    def calculate_synth_message(self, cat, most_common, chnge_val):
        findctrl, s_controls = self.cat2synth[most_common][0], copy.deepcopy(self.cat2synth[cat][1])
        print('cat:  {}  most common {} ch val  {}'.format(cat, most_common, chnge_val))

        for k, val in s_controls.items():
            # i decide to change the cntrl of the current most_common
            if k == findctrl and (val[1] >= chnge_val):
                print('cat:  {}   k:  {}  val[1] {} most_common {}'.format(cat, k, val[1], most_common))
                val[1] += chnge_val

        self.cat2synth[cat][1] = s_controls
        self.ctrl_message = [v[1] for v in s_controls.values()]
        return self.ctrl_message

    def reset_synth(self):
        for val in self.cat2synth.values():
            val[1] = self.synth_controls
