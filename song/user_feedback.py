from collections import Counter


class Tonality:
    '''
    idea of tonality counter combined with rules for FX chains and Sample Triggering in
    Ableton Live
    '''

    tonality_counter = Counter()
    chain_duration = 5  # specifies how many utterances are needed to change the tonality
    tonality_lock = False

    category_to_chain = {
        # every category points to a FX Chain and a ctrl value
        'praise': ['Delay', 5],
        'lecture': ['Vocoder', 8],
        'insinuation': ['FreqShift', -7],
        'dissence': ['Distortion', -5],
        'concession': ['Delay', 2]
    }
    chain_controls = {
        # every chain refers to a LIVE FX Bus  with a Audio Effekt Rack
        # the Rack has a value for the Chain Selector, a ccnr (for Osculator) and a standard ctrl_value
        'FreqShift' : [15, 10, 65],
        'Vocoder': [32, 15, 95],
        'Distortion': [60, 20, 25],
        'Delay': [90, 25, 65],
        'Clean': [115, 0, 0]
    }

    def __init__(self, categories):
        self.tonality_counter = Counter(categories)
        self.FX_KEY = 'Clean'
        self.chain = self.chain_controls[self.FX_KEY]
        self.ctrl_val = 0 # the value being sent with SongServer.send_fx is calculated with calculate_rack_values
        self.last_cats = []
        self.last_value = 0
        self.most_common = ''

    def update_tonality(self, cat):
        self.tonality_counter[cat] += 1
        self.calculate_rack_values(cat)
        # print("tonalities: ", self.tonality_counter)

    def calculate_rack_values(self, cat):
        '''
        1. after 10 utterances, the most_common category defines the FX chain
        2. only if all other categories have had at least had 5 updates (self.last_cats), a new FX_kEY is
        generated by the most_common category at that moment
        3. the self.ctrl_value is calculated as a deviation from a standard value defined in self.chain_controls
        '''
        #  an FX chain is selected, if more than 10 entries have occured
        if sum(self.tonality_counter.values()) > 10:
            # print("cat {}   locked?: {} most common: {}".format(cat, self.tonality_lock, self.most_common))
            if not self.tonality_lock:
                self.most_common = self.tonality_counter.most_common(1)[0][0]
                self.FX_KEY = self.category_to_chain[self.most_common][0]
                self.tonality_lock = True
            if cat not in self.last_cats and self.tonality_counter[cat] % self.chain_duration == 0:
                self.last_cats.append(cat)
            elif len(self.last_cats) == len(self.tonality_counter):
                print("\t RESET FX")
                self.tonality_lock = False
                self.last_cats = []

        self.chain = self.chain_controls[self.FX_KEY]
        self.last_value = self.chain[2]
        self.ctrl_val = self.last_value + self.category_to_chain[cat][1]


class SynthFeedback(Tonality):
    MIDI_feedback_controls = {}
    synth_controls = ['c1', 'c2', 'c3', 'c4', 'c5']

    def __init__(self, categories):
        super(SynthFeedback, self).__init__(categories)
        self.rename_chain_controls()

    def rename_chain_controls(self):
        for idx in range(len(self.chain_controls.values())):
            for key in self.chain_controls.keys():
                self.MIDI_feedback_controls[self.synth_controls[idx]] = self.chain_controls[key]
